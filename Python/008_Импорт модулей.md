# Общие сведения
Для импорта библиотек используется ключевое слово `import`

# Типы импортов

## Абсолютный путь импорта
``` python
С:\Test\PACKAGE\__init__.py

<<>>
	import PACKAGE.exm_pack_1
	NAME = "Это пакет 1"

-----
С:\Test\PACKAGE\exm_pack_1.py
	
	def get_pack():
		print("Это часть пакета 1")
```

## Относительный путь импорта
``` python
С:\Test\PACKAGE\__init__.py

	import PACKAGE.exm_pack_1
<<Импорт влоеженного пакета>>
	from .PACKAGE_1 import \*
<<>>

	NAME = "Это пакет 1"

-----
С:\Test\PACKAGE\exm_pack_1.py
	
	def get_pack():
		print("Это часть пакета 1")


----------


С:\Test\PACKAGE\PACKAGE_1\__init__.py

	import PACKAGE.exm_1
	NAME = "ВЛОЖЕННЫЙ ПАКЕТ"

-----
С:\Test\PACKAGE\PACKAGE_1\exm_1.py

<<Во вложенном пакете можно испортировать внешние модули>>
	from ..exm_pack_1 import get_pack
```


# Импорт собственных модулей
Модуль — обычный текстовый файл \*.py

``` python
С:\Test\exm_module.py

	import math
	
	A = 1
	
	def sin(x):
		print(x, "Переопределение функции sin() из файла
		exm_module.py")
		
-----
С:\Test\exm_mod_2.py
	
<<Будут доступны все переменные (ссылки) из exm_module>>
	import exm_module
	
	B = exm_module.A
	print(B) --> 1
	
<<Также все импортированные ранее бибилиотеки>>
	A = exm_module.math.sin(1)
	print(A) --> 0.84
	
<<При этом мы можем получить переопределённую функцию sin()>>
	С = exm_module.sin(1)
	--> 1 Переопределение функции sin() из файла exm_module.py
	--> None Так как функция всегда неявно возвращает None

-----
С:\Test\FOLDERS\exm_mod_3.py

<<Если файл не находится по стандартному пути поиска модулей
python (sys.path, и т.д.), то при импорте нужно указывать полный
путь к файлу>>
	
С:\\Test\\exm_mod_2.py
	import FOLDERS.exm_mod_3.py

```

## Особенности импорта
Все команды находящие непосредственно в глобальной области видимости файла при его импорте будут выполнены если не указано другое.

``` python
С:\Test\exm_mod_1.py

	print("exm_mod_1")

-----
С:\Test\exm_mod_2.py

	import exm_mod_1
	
	print("exm_mod_2")
	
<<При запуске данного файла исполнятся все команды импортируемого модуля>>
	--> exm_mod_1
```

### Циклический импорт

``` python
С:\Test\exm_mod_1.py

	import exm_mod_2
	print("exm_mod_1")

-----
С:\Test\exm_mod_2.py

	import exm_mod_1
	print("exm_mod_2")
	
<<При запуске данного файла исполнятся все команды импортируемого модуля по цепочке>>
	--> exm_mod_2
	--> exm_mod_1
	--> exm_mod_2

```

==Ход событий (подробно, по шагам)==
1. Python запускает файл `exm_mod_2.py` как **скрипт**. Его имя модуля в этом процессе — `__main__`. Начинается исполнение верхнего уровня `exm_mod_2` (в виде `__main__`).
2. В `__main__` встречается `import exm_mod_1`. Интерпретатор:
    - проверяет `sys.modules` — модуля с именем `'exm_mod_1'` там нет;
    - создаёт объект-модуль `exm_mod_1` и помещает его в `sys.modules['exm_mod_1']` **до** исполнения его кода (это важно для разрыва циклов);
    - начинает исполнение кода `exm_mod_1` (выполняется как модуль `exm_mod_1`).
3. В процессе исполнения `exm_mod_1` первой строкой идёт `import exm_mod_2`. Интерпретатор:
    - проверяет `sys.modules` для ключа `'exm_mod_2'`.  
        Сейчас в `sys.modules` есть запись для `__main__` (скрипт), но **нет** записи `'exm_mod_2'` (имя модуля, как при импорте), поэтому интерпретатор создаёт новый модуль с именем `'exm_mod_2'` и помещает его в `sys.modules['exm_mod_2']`;
    - начинает исполнение кода этого нового модуля `exm_mod_2` (отдельного от `__main__`).
4. Исполнение (нового) `exm_mod_2` достигает `import exm_mod_1`. Теперь `sys.modules` уже содержит `'exm_mod_1'` (создан на шаге 2), поэтому импорт возвращает **тот же объект-модуль** `exm_mod_1` (возможно ещё частично инициализированный), и дальнейшего повторного выполнения `exm_mod_1` не происходит.
5. Продолжается выполнение нового `exm_mod_2` — достигается `print("exm_mod_2")`. Это приводит к **первому** выводу:
    `exm_mod_2`
6. Выполнение нового `exm_mod_2` завершается и управление возвращается в контекст выполнения `exm_mod_1` (шаг 3). В `exm_mod_1` теперь доходит до `print("exm_mod_1")` и выполняет его — **второй** вывод:
    `exm_mod_1`
7. После завершения `exm_mod_1` управление возвращается в исходный скрипт `__main__` (оригинальный `exm_mod_2.py`), где импорт `exm_mod_1` завершился, и далее исполняется оставшаяся часть `__main__` — `print("exm_mod_2")`. Это даёт **третий** вывод:
    `exm_mod_2`
Ключевой момент: когда вы запускаете файл напрямую, он выполняется как `__main__`, а не как модуль с его именем. Поэтому при импорте этого же файла из другого модуля, Python считает это разными сущностями и выполняет код дважды.

# \_\_main__
У каждого файла \*.py есть служебная переменная `__name__` которая отражает название файла, НО при запуске данного файла становится `__main__`

``` python
С:\Test\exm_mod_1.py
	
	NAME = "A"
	
	if __name__ == "main":
		for i in range(3):
			print(NAME)
	else:
		print(__name__)

-----
С:\Test\exm_mod_2.py

	import exm_mod_1
	
	--> exm_mod_1
```